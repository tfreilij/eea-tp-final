---
title: "AD vs FTD"
subtitle: "An谩lisis descriptivo, modelos de regresi贸n log铆stica y permutaciones"
author: "Canziani, Ver贸nica - Freilij, Tom谩s - Gromadzyn, Guido"
date: "`r format(Sys.Date(), '%d/%m/%Y')`"
lang: es

output:
  html_document:
    toc: true
    toc_float:
      collapsed: false
      smooth_scroll: true
    number_sections: true
    theme: flatly        # otro tema lindo
    highlight: pygments
    df_print: paged
    fig_width: 7
    fig_height: 5
    keep_md: true        # opcional, guarda el .md

fontsize: 11pt

---

```{r setup, include=FALSE}
knitr::opts_chunk$set(warning = FALSE, message = FALSE)
```

## Carga de librerias

```{r}
library(tidyverse)
library(gt)
library(kableExtra)
library(gtsummary)
library(corrplot)
library(car)
library(caret)
library(pROC)
```

## Carga de dato

```{r}
library(readxl)
file_path <- "/home/guido/Downloads/CogED xDiag xVero.xlsx"
dataAD <- read_excel(file_path, sheet = "CogEd AD", range = "B1:R478")



dataCN <- read_excel(file_path, sheet = "CogEd CN", range = "A1:Q669")

dataFTD <- read_excel(file_path, sheet = "CogEd FTD", range = "A1:Q274")

cat("dataAD:",  dim(dataAD),  "\n")
cat("dataCN:",  dim(dataCN),  "\n")
cat("dataFTD:", dim(dataFTD), "\n")
```

## Limpieza de variables

```{r}
data <- rbind(dataAD, dataCN, dataFTD)
data$clinical_diagnosis <- as.factor(data$clinical_diagnosis)
data$cog_tmt_a_err <- as.numeric(ifelse(data$cog_tmt_a_err=="completed", 0, data$cog_tmt_a_err))
data$cog_tmt_a_corr <- as.numeric(ifelse(data$cog_tmt_a_corr=="completed", 25, data$cog_tmt_a_corr))
data$cog_tmt_b_err <- as.numeric(ifelse(data$cog_tmt_b_err=="completed", 0, data$cog_tmt_b_err))
data$cog_tmt_b_corr <- as.numeric(ifelse(data$cog_tmt_b_corr=="completed", 25, data$cog_tmt_b_corr))
data$cog_digits_forward_span <- as.numeric(ifelse(data$cog_digits_forward_span=="completed", 8, data$cog_digits_forward_span))
data$cog_digits_backward_span <- as.numeric(ifelse(data$cog_digits_backward_span=="completed", 7, data$cog_digits_backward_span))
data$cog_digits_forward_total <- ifelse(data$cog_digits_forward_total>16, NA, data$cog_digits_forward_total)
data$cog_digits_backward_total <- ifelse(data$cog_digits_backward_total>14, NA, data$cog_digits_backward_total)
data$cog_tmt_a <- ifelse(data$cog_tmt_a>150, NA, data$cog_tmt_a)
data$cog_tmt_b <- ifelse(data$cog_tmt_b>300, NA, data$cog_tmt_b)
```


## Distribuci贸n de valores

```{r}

plot_col_hist <- function(data, title,column) {
  hist(data[[column]],
       main = title,
       xlab = "A帽os",
       ylab = "Frecuencia",
       col = "lightblue",
       breaks = 20)
}

plot_col_hist(data,   "A帽os de educaci贸n","cog_ed")
plot_col_hist(dataAD, "A帽os de educaci贸n AD","cog_ed")
plot_col_hist(dataCN, "A帽os de educaci贸n CN","cog_ed")
plot_col_hist(dataFTD, "A帽os de educaci贸n FTD","cog_ed")


```

```{r}


plot_col_hist(data, "cog_digits_forward_total","cog_digits_forward_total")
plot_col_hist(data, "cog_digits_backward_total","cog_digits_backward_total")
plot_col_hist(data, "mmse_total","mmse_total")
plot_col_hist(data, "cog_category_animals","cog_category_animals")
plot_col_hist(data, "cog_category_vegetables","cog_category_vegetables")
plot_col_hist(data, "cog_tmt_a","cog_tmt_a")
plot_col_hist(data, "cog_tmt_b","cog_tmt_b")

```


```{r}


data <- data %>%
  select(-codMP, -id_paciente) %>%
  mutate(tests_no_hechos = rowSums(is.na(across(c(cog_digits_forward_total, cog_category_animals, cog_category_vegetables, cog_tmt_a, cog_tmt_b)))))

```

## Descarte de pacientes con 5 tests no hechos

```{r}
data <- data %>%
  filter(tests_no_hechos < 5)
```



## Tabla 1 (considerando 3 categorias)

```{r}
tabla1 <- 
  tbl_summary(
    data = data,
    by = clinical_diagnosis,          # para comparar grupos
    include = c(                      #  incluimos solo estas variables
      cog_ed,
      cog_digits_forward_total,
      cog_digits_forward_span,
      cog_digits_backward_total,
      cog_digits_backward_span,
      mmse_total,
      cog_category_animals,
      cog_category_vegetables,
      cog_tmt_a,
      cog_tmt_a_corr,
      cog_tmt_a_err,
      cog_tmt_b,
      cog_tmt_b_corr,
      cog_tmt_b_err
    ),
    missing = "ifany",
    missing_text = "No realizado",
    label = list(
      cog_ed ~ "A帽os de educaci贸n",
      cog_digits_forward_total  ~ "Digits forward total",
      cog_digits_forward_span   ~ "Digits forward span",
      cog_digits_backward_total ~ "Digits backwards total",
      cog_digits_backward_span  ~ "Digits backwards span",
      mmse_total                ~ "Mini mental",
      cog_category_animals      ~ "Fluidez sem谩ntica (animales)",
      cog_category_vegetables   ~ "Fluidez sem谩ntica (vegetales)",
      cog_tmt_a       ~ "Atenci贸n sostenida (tiempo)",
      cog_tmt_a_corr  ~ "Atenci贸n sostenida (correctas)",
      cog_tmt_a_err   ~ "Atenci贸n sostenida (errores)",
      cog_tmt_b       ~ "Funciones ejecutivas (tiempo)",
      cog_tmt_b_corr  ~ "Funciones ejecutivas (correctas)",
      cog_tmt_b_err   ~ "Funciones ejecutivas (errores)"
    ),
    type = list(                     # forzamos todas como continuas
      cog_ed ~ "continuous",
      cog_digits_forward_total  ~ "continuous",
      cog_digits_forward_span   ~ "continuous",
      cog_digits_backward_total ~ "continuous",
      cog_digits_backward_span  ~ "continuous",
      mmse_total                ~ "continuous",
      cog_category_animals      ~ "continuous",
      cog_category_vegetables   ~ "continuous",
      cog_tmt_a       ~ "continuous",
      cog_tmt_a_corr  ~ "continuous",
      cog_tmt_a_err   ~ "continuous",
      cog_tmt_b       ~ "continuous",
      cog_tmt_b_corr  ~ "continuous",
      cog_tmt_b_err   ~ "continuous"
    ),
    statistic = list(
      all_continuous()  ~ "{median} ({p25}, {p75})",
      all_categorical() ~ "{n} ({p}%)"
    )
  ) %>%
  add_overall() %>%
  add_p(
    test = list(
      all_continuous()  ~ "kruskal.test",
      all_categorical() ~ "chisq.test"
    )
  ) %>%
  bold_labels()

tabla1

```

## Tabla 1 considerando AD vs FTD

```{r}
data2 <- data %>%
  filter(clinical_diagnosis != "CN") 
data2$clinical_diagnosis <- droplevels(data2$clinical_diagnosis)

tabla1 <- 
  tbl_summary(
    data = data2,
    by = clinical_diagnosis,          # para comparar grupos
    include = c(                      #  incluimos solo estas variables
      cog_ed,
      cog_digits_forward_total,
      cog_digits_forward_span,
      cog_digits_backward_total,
      cog_digits_backward_span,
      mmse_total,
      cog_category_animals,
      cog_category_vegetables,
      cog_tmt_a,
      cog_tmt_a_corr,
      cog_tmt_a_err,
      cog_tmt_b,
      cog_tmt_b_corr,
      cog_tmt_b_err
    ),
    missing = "ifany",
    missing_text = "No realizado",
    label = list(
      cog_ed ~ "A帽os de educaci贸n",
      cog_digits_forward_total  ~ "Digits forward total",
      cog_digits_forward_span   ~ "Digits forward span",
      cog_digits_backward_total ~ "Digits backwards total",
      cog_digits_backward_span  ~ "Digits backwards span",
      mmse_total                ~ "Mini mental",
      cog_category_animals      ~ "Fluidez sem谩ntica (animales)",
      cog_category_vegetables   ~ "Fluidez sem谩ntica (vegetales)",
      cog_tmt_a       ~ "Atenci贸n sostenida (tiempo)",
      cog_tmt_a_corr  ~ "Atenci贸n sostenida (correctas)",
      cog_tmt_a_err   ~ "Atenci贸n sostenida (errores)",
      cog_tmt_b       ~ "Funciones ejecutivas (tiempo)",
      cog_tmt_b_corr  ~ "Funciones ejecutivas (correctas)",
      cog_tmt_b_err   ~ "Funciones ejecutivas (errores)"
    ),
    type = list(                     # forzamos todas como continuas
      cog_ed ~ "continuous",
      cog_digits_forward_total  ~ "continuous",
      cog_digits_forward_span   ~ "continuous",
      cog_digits_backward_total ~ "continuous",
      cog_digits_backward_span  ~ "continuous",
      mmse_total                ~ "continuous",
      cog_category_animals      ~ "continuous",
      cog_category_vegetables   ~ "continuous",
      cog_tmt_a       ~ "continuous",
      cog_tmt_a_corr  ~ "continuous",
      cog_tmt_a_err   ~ "continuous",
      cog_tmt_b       ~ "continuous",
      cog_tmt_b_corr  ~ "continuous",
      cog_tmt_b_err   ~ "continuous"
    ),
    statistic = list(
      all_continuous()  ~ "{median} ({p25}, {p75})",
      all_categorical() ~ "{n} ({p}%)"
    )
  ) %>%
  add_overall() %>%
  add_p(
    test = list(
      all_continuous()  ~ "wilcox.test",
      all_categorical() ~ "chisq.test"
    )
  ) %>%
  bold_labels()

tabla1
```



## Funci贸n auxiliar para correlaciones

```{r}

plot_corr <- function(df, vars_to_keep, label_map, title = NULL) {
  
  # Filter only numeric columns listed in vars_to_keep
  data_num <- df %>% 
    select(all_of(vars_to_keep))
  
  # Compute correlation matrix
  mat_cor <- cor(data_num, use = "pairwise.complete.obs", method = "pearson")
  
  # Apply labels
  mat_cor_labeled <- mat_cor
  colnames(mat_cor_labeled) <- label_map[colnames(mat_cor_labeled)]
  rownames(mat_cor_labeled) <- label_map[rownames(mat_cor_labeled)]
  
  # Palette
  paleta <- colorRampPalette(RColorBrewer::brewer.pal(11, "RdBu"))(100)
  
  # Plot
  corrplot(mat_cor_labeled,
           method = "color",
           type = "upper",
           order = "hclust",
           tl.cex = 0.8,
           col = paleta,
           title = title,
           mar = c(0,0,2,0))
}

```


## Gr谩fico de correlaciones
```{r}
data_num <- data %>% 
  select(where(is.numeric))

mat_cor <- cor(data_num, use = "pairwise.complete.obs", method = "pearson")

label_map <- c(
  mmse_total                = "MMSE",
  cog_digits_forward_total  = "DF total",
  cog_digits_backward_total = "DB total",
  cog_digits_forward_span   = "DF span",
  cog_digits_backward_span  = "DB span",
  cog_category_animals      = "Fluidez animales",
  cog_category_vegetables   = "Fluidez vegetales",
  cog_tmt_a       = "TMT-A (tiempo)",
  cog_tmt_a_corr  = "TMT-A (corr.)",
  cog_tmt_a_err   = "TMT-A (errores)",
  cog_tmt_b       = "TMT-B (tiempo)",
  cog_tmt_b_corr  = "TMT-B (corr.)",
  cog_tmt_b_err   = "TMT-B (errores)"
)

vars_to_keep <- names(label_map)

plot_corr(data,  vars_to_keep, label_map, title = "Correlaciones")

```


## Gr谩fico de correlaciones (simplificado)

```{r}
data_num <- data %>% 
  select(where(is.numeric))

mat_cor <- cor(data_num, use = "pairwise.complete.obs", method = "pearson")

label_map <- c(
  mmse_total                = "Desempe帽o Total (MMSE)",
  cog_digits_forward_total  = "Digits Forward",
  cog_digits_backward_total = "Digits Backward",
  cog_category_animals      = "Fluidez animales",
  cog_category_vegetables   = "Fluidez vegetales",
  cog_tmt_a       = "Atenci贸n sostenida",
  cog_tmt_b       = "Funciones Ejecutivas"
)


vars_to_keep <- names(label_map)

plot_corr(data,  vars_to_keep, label_map, title = "Correlaciones")

```


```{r}
# Names you want to keep (those used in label_map)
label_map <- c(
  mmse_total                = "Desempe帽o Total (MMSE)",
  cog_digits_forward_total  = "Digits Forward",
  cog_digits_backward_total = "Digits Backward",
  cog_category_animals      = "Fluidez animales",
  cog_category_vegetables   = "Fluidez vegetales",
  cog_tmt_a       = "Atenci贸n sostenida",
  cog_tmt_b       = "Funciones Ejecutivas"
)

vars_to_keep <- names(label_map)

plot_corr(dataAD,  vars_to_keep, label_map, title = "Correlaciones - AD")
plot_corr(dataCN,  vars_to_keep, label_map, title = "Correlaciones - CN")
plot_corr(dataFTD, vars_to_keep, label_map, title = "Correlaciones - FTD")

```
```{r}

label_map <- c(
  mmse_total                = "Desempe帽o Total (MMSE)",
  cog_digits_forward_total  = "Memoria",
  cog_category_animals      = "Lenguaje",
  cog_tmt_b       = "Funciones Ejecutivas - Atenci贸n"
)

vars_to_keep <- names(label_map)

plot_corr(dataAD,  vars_to_keep, label_map, title = "Correlaciones - AD")
plot_corr(dataCN,  vars_to_keep, label_map, title = "Correlaciones - CN")
plot_corr(dataFTD, vars_to_keep, label_map, title = "Correlaciones - FTD")

```
```{r}

# Columnas y labels
label_map <- c(
  mmse_total                = "Desempe帽o Total (MMSE)",
  cog_digits_forward_total  = "Memoria",
  cog_category_animals      = "Lenguaje",
  cog_tmt_a                 = "Atenci贸n",
  cog_tmt_b                 = "Funciones Ejecutivas - Atenci贸n"
)

vars_to_keep <- names(label_map)

# Graficar correlaciones originales
plot_corr(dataAD, vars_to_keep, label_map, title = "Correlaciones - AD (original)")

# N煤mero de permutaciones a mostrar
n_perm_show <- 5
set.seed(123) # para reproducibilidad

# Elegimos la columna a permutar
column_to_permute <- "cog_tmt_a"

# Generamos 5 permutaciones diferentes
for (i in 1:n_perm_show) {
  data_perm <- dataAD
  data_perm[[column_to_permute]] <- sample(data_perm[[column_to_permute]])
  
  # Graficar correlaci贸n de esta permutaci贸n
  plot_corr(data_perm, vars_to_keep, label_map, 
            title = paste("Correlaciones - AD (perm", i, ")"))
}


```

```{r}

# Columnas y labels
label_map <- c(
  mmse_total                = "Desempe帽o Total (MMSE)",
  cog_digits_forward_total  = "Memoria",
  cog_category_animals      = "Lenguaje",
  cog_tmt_a                 = "Atenci贸n",
  cog_tmt_b                 = "Funciones Ejecutivas - Atenci贸n"
)

vars_to_keep <- names(label_map)

# Correlaci贸n original
plot_corr(dataAD, vars_to_keep, label_map,
          title = "Correlaciones - AD (original)")

# N煤mero de permutaciones a mostrar por par
n_perm_show <- 5
set.seed(123)

# Todas las combinaciones de pares
pairs <- combn(vars_to_keep, 2, simplify = FALSE)

# Loop por cada par de columnas
for (pair in pairs) {
  
  col_perm <- pair[1]
  col_ref  <- pair[2]
  
  for (i in seq_len(n_perm_show)) {
    
    data_perm <- dataAD
    data_perm[[col_perm]] <- sample(data_perm[[col_perm]])
    
    plot_corr(
      data_perm,
      vars_to_keep,
      label_map,
      title = paste0(
        "AD | permutando: ", label_map[col_perm],
        " vs ", label_map[col_ref],
        " (perm ", i, ")"
      )
    )
  }
}


```

```{r}
```


```{r}
#Limpio la base de las variables de digits span

#todos los datos
data <- data %>%
  select(-cog_digits_backward_span, -cog_digits_forward_span, -tests_no_hechos)

#solamente AD y FTD
data2 <- data %>%
  filter(clinical_diagnosis != "CN") 
data2$clinical_diagnosis <- droplevels(data2$clinical_diagnosis)
  
```

```{r}
vars <- colnames(data)
vars <- vars[2:13]
```


```{r}
#Test de correlaciones luego de las permutaciones. Permuta en cada par de variables. N=10000. Luego ordena seg煤n cu谩n desviado est谩 de la media el delta de correlaci贸n (o sea cu谩nto)

perm_corr_test <- function(data, x, y, n_perm = 10000, method = "spearman") {
  
  r_obs <- cor(data[[x]], data[[y]], method = method, use = "complete.obs")
  
  r_perm <- replicate(n_perm, {
    cor(
      sample(data[[x]]),
      data[[y]],
      method = method,
      use = "complete.obs"
    )
  })
  
  tibble(
    var_x = x,
    var_y = y,
    r_obs = r_obs,
    r_perm_mean = mean(r_perm),
    r_perm_sd = sd(r_perm),
    delta_r = r_obs - mean(r_perm),
    p_value = (sum(abs(r_perm) >= abs(r_obs)) + 1) / (n_perm + 1),
    z_perm = (r_obs - mean(r_perm)) / sd(r_perm)

  )
}



library(purrr)

results_all <- map_dfr(
  combn(vars, 2, simplify = FALSE),
  ~ perm_corr_test(data, .x[1], .x[2], n_perm = 10000)
)

results_all <- results_all |>
  dplyr::mutate(
    p_adj = p.adjust(p_value, method = "BH")
  )

results_all |>
  arrange(desc(abs(z_perm)))

```


```{r}
#Ahora esto lo que arma es un score de fuerza de colinealidad sumando los valores absolutos de cada delta r para cada permutaci贸n. Con lo cual es un valor m谩s general sobre colinealidad de esa variable.

colinearity_score <- function(data, x, vars, n_perm = 10000, method = "spearman") {
  
  others <- setdiff(vars, x)
  
  deltas <- sapply(others, function(y) {
    
    r_obs <- cor(data[[x]], data[[y]], method = method, use = "complete.obs")
    
    r_perm <- replicate(
      n_perm,
      cor(sample(data[[x]]), data[[y]], method = method, use = "complete.obs")
    )
    
    r_obs - mean(r_perm)
  })
  
  tibble::tibble(
    var = x,
    colinearity_strength = sum(abs(deltas)),   # fuerza total
    mean_delta = mean(abs(deltas)),             # promedio
    max_delta = max(abs(deltas)),               # peor caso
    n_links = length(deltas)                    # cu谩ntas variables compara
  )
}

library(purrr)
library(dplyr)

colinearity_tbl <- map_dfr(
  vars,
  ~ colinearity_score(
      data  = data,
      x     = .x,
      vars  = vars,
      n_perm = 10000   # o 5000 / 10000 si quer茅s
    )
)

colinearity_tbl %>%
  arrange(desc(colinearity_strength))


```
```{r}
#Ahora hago lo mismo pero solamente con la data AD + FTD

results_all <- map_dfr(
  combn(vars, 2, simplify = FALSE),
  ~ perm_corr_test(data2, .x[1], .x[2], n_perm = 10000)
)

results_all <- results_all |>
  dplyr::mutate(
    p_adj = p.adjust(p_value, method = "BH")
  )

results_all |>
  arrange(desc(abs(z_perm)))

```

```{r}
colinearity_tbl <- map_dfr(
  vars,
  ~ colinearity_score(
      data  = data2,
      x     = .x,
      vars  = vars,
      n_perm = 10000   # o 5000 / 10000 si quer茅s
    )
)

colinearity_tbl %>%
  arrange(desc(colinearity_strength))

```

```{r}
#Modelo logistico con todas las variables para ver cuales dan "significativas"
modelo_todas <- glm(clinical_diagnosis~., data2, family=binomial)
summary(modelo_todas)
vif(modelo_todas)

#A pesar de que las variables son colineales, el VIF no es preocupantemente alto
```

```{r}
#Hago modelo logistico con todas las variables y pero evaluando el AUC por cross validation

library(dplyr)
library(rsample)
library(purrr)
library(pROC)

#Funcion para calcular AUC de regresi贸n log铆stica por CV

cv_auc_logistic <- function(data, outcome, predictors, v = 10) {
  
  df <- data[, c(outcome, predictors)]
  
  formula <- as.formula(
    paste(outcome, "~", paste(predictors, collapse = " + "))
  )
  
  folds <- vfold_cv(
    df,
    v = v,
    strata = !!sym(outcome)
  )
  
  aucs <- map_dbl(folds$splits, function(split) {
    
    train <- analysis(split)
    test  <- assessment(split)
    
    fit <- glm(
      formula,
      data = train,
      family = binomial()
    )
    
    prob <- predict(fit, test, type = "response")
    
    roc(
      response  = test[[outcome]],
      predictor = prob,
      quiet = TRUE
    )$auc
  })
  
  tibble(
    auc_mean = mean(aucs),
    auc_sd   = sd(aucs),
    auc_min  = min(aucs),
    auc_max  = max(aucs)
  )
}

```

```{r}

#Calculo con todas las variables, AUC medio de 0.67
set.seed(123)

auc_full <- cv_auc_logistic(
  data       = data2,
  outcome    = "clinical_diagnosis",
  predictors = vars,
  v          = 10
)

auc_full

```

```{r}
#Tenia este "orden" de "Fortaleza de colinealidad". Voy a ir sacando de a una y a analizar el AUC
colinearity_tbl %>%
  arrange(desc(colinearity_strength))
```

```{r}
#Voy sacando de a una y calculando, sumo todo a una tabla


vars_reduced <- c("cog_tmt_a", "cog_digits_backward_total", "mmse_total","cog_category_animals", "cog_digits_forward_total", "cog_category_vegetables", "cog_tmt_b_corr", "cog_tmt_a_corr", "cog_ed")

set.seed(123)

auc_reduced <- cv_auc_logistic(
  data       = data2,
  outcome    = "clinical_diagnosis",
  predictors = vars_reduced,
  v          = 10
)

auc_reduced
```
```{r}
vars_reduced2 <- c("cog_digits_backward_total", "mmse_total","cog_category_animals", "cog_digits_forward_total", "cog_category_vegetables", "cog_tmt_b_corr", "cog_tmt_a_corr", "cog_ed")

set.seed(123)

auc_reduced2 <- cv_auc_logistic(
  data       = data2,
  outcome    = "clinical_diagnosis",
  predictors = vars_reduced2,
  v          = 10
)

auc_reduced2
```
```{r}
vars_reduced3 <- c( "mmse_total","cog_category_animals", "cog_digits_forward_total", "cog_category_vegetables","cog_tmt_b_corr", "cog_tmt_a_corr",  "cog_ed")

set.seed(123)

auc_reduced3 <- cv_auc_logistic(
  data       = data2,
  outcome    = "clinical_diagnosis",
  predictors = vars_reduced3,
  v          = 10
)

auc_reduced3
```
```{r}
vars_reduced4 <- c("cog_category_animals", "cog_digits_forward_total", "cog_category_vegetables",  "cog_tmt_b_corr", "cog_tmt_a_corr", "cog_ed")

set.seed(123)

auc_reduced4 <- cv_auc_logistic(
  data       = data2,
  outcome    = "clinical_diagnosis",
  predictors = vars_reduced4,
  v          = 10
)

auc_reduced4
```

```{r}
#A medida que sacamos variables por colinealidad, PERDEMOS AUC

tablaauc <- rbind(auc_reduced, auc_reduced2, auc_reduced3, auc_reduced4)
rownames(tablaauc) <- c("Sacando 1 variable", "Sacando 2 variables", "Sacando 3 variables", "Sacando 4 variables")
tablaauc
```

```{r}
#Entonces probamos hacer Elastic Net (Lasso + Ridge, o cada una de ellas) para manejar colinealidad y seleccionar variables

library(glmnet)
library(pROC)
library(rsample)
library(purrr)
library(dplyr)

cv_auc_elastic <- function(data, outcome, predictors, alpha = 0.5, v = 10, seed = 123) {
  
  set.seed(seed)
  
  folds <- vfold_cv(data, v = v, strata = !!sym(outcome))
  
  aucs <- purrr::map_dbl(seq_along(folds$splits), function(i) {
    
    set.seed(seed + i)   #  CLAVE
    
    split <- folds$splits[[i]]
    train <- analysis(split)
    test  <- assessment(split)
    
    X_train <- model.matrix(
      as.formula(paste(outcome, "~", paste(predictors, collapse = " + "))),
      train
    )[,-1]
    
    X_test <- model.matrix(
      as.formula(paste(outcome, "~", paste(predictors, collapse = " + "))),
      test
    )[,-1]
    
    y_train <- train[[outcome]]
    y_test  <- test[[outcome]]
    
    cv_fit <- cv.glmnet(
      X_train,
      y_train,
      family = "binomial",
      alpha = alpha,
      nfolds = 10   # fijar folds internos
    )
    
    prob <- predict(cv_fit, X_test, s = "lambda.min", type = "response")
    
    pROC::roc(y_test, as.vector(prob), quiet = TRUE)$auc
  })
  
  tibble::tibble(
    model = paste0("Elastic Net (alpha=", alpha, ")"),
    auc_mean = mean(aucs),
    auc_sd   = sd(aucs)
  )
}

```

```{r}
data2_clean <- data2[, c("clinical_diagnosis", vars)] %>%
+     na.omit()


#Ridge es el mejor, porque regulariza y maneja la colinealidad pero no elimina variables

auc_enet_ridge <- cv_auc_elastic(
  data       = data2_clean,
  outcome    = "clinical_diagnosis",
  predictors = vars,
  alpha      = 0,
  v          = 10
)

auc_enet_ridge

```
```{r}
auc_enet <- cv_auc_elastic(
  data       = data2_clean,
  outcome    = "clinical_diagnosis",
  predictors = vars,
  alpha      = 0.5,
  v          = 10
)

auc_enet

```
```{r}
auc_enet_lasso <- cv_auc_elastic(
  data       = data2_clean,
  outcome    = "clinical_diagnosis",
  predictors = vars,
  alpha      = 1,
  v          = 10
)

auc_enet_lasso

```


```{r}
#Esta calcula tambien los coeficientes para ver qu茅 selecciona Lasso

cv_auc_elastic_with_coefs <- function(
  data, outcome, predictors,
  alpha = 1, v = 10, seed = 123
) {
  
  set.seed(seed)
  folds <- vfold_cv(data, v = v, strata = !!sym(outcome))
  
  aucs <- numeric(v)
  selected_vars <- vector("list", v)
  
  for (i in seq_along(folds$splits)) {
    
    set.seed(seed + i)
    
    split <- folds$splits[[i]]
    train <- analysis(split)
    test  <- assessment(split)
    
    X_train <- model.matrix(
      as.formula(paste(outcome, "~", paste(predictors, collapse = " + "))),
      train
    )[,-1]
    
    X_test <- model.matrix(
      as.formula(paste(outcome, "~", paste(predictors, collapse = " + "))),
      test
    )[,-1]
    
    y_train <- train[[outcome]]
    y_test  <- test[[outcome]]
    
    cv_fit <- cv.glmnet(
      X_train, y_train,
      family = "binomial",
      alpha = alpha,
      nfolds = 5
    )
    
    # --- AUC ---
    prob <- predict(cv_fit, X_test, s = "lambda.min", type = "response")
    aucs[i] <- pROC::roc(y_test, as.vector(prob), quiet = TRUE)$auc
    
    # --- VARIABLES SELECCIONADAS ---
    coefs <- coef(cv_fit, s = "lambda.min")
    selected_vars[[i]] <- rownames(coefs)[as.numeric(coefs) != 0]
  }
  
  tibble::tibble(
    auc_mean = mean(aucs),
    auc_sd   = sd(aucs),
    selected_vars = list(unlist(selected_vars))
  )
}

```

```{r}
res_lasso <- cv_auc_elastic_with_coefs(
  data2_clean,
  "clinical_diagnosis",
  vars,
  alpha = 1
)

```

```{r}

#Aca se ve la importancia Lasso de cada variable
library(dplyr)

lasso_importance <- tibble(var = res_lasso$selected_vars[[1]]) %>%
  count(var) %>%
  mutate(freq = n / 10) %>%   # 10 folds
  arrange(desc(freq))

lasso_importance
```

```{r}
#Ahora calculo la importancia por permutaci贸n de cada variable: de a una variable, permuto y veo cu谩nto cambia el AUC

perm_importance_cv <- function(
  data, outcome, predictors,
  alpha = 0, v = 10, n_perm = 20, seed = 123
) {
  
  set.seed(seed)
  folds <- rsample::vfold_cv(data, v = v, strata = !!sym(outcome))
  
  all_imp <- list()
  
  for (i in seq_along(folds$splits)) {
    
    set.seed(seed + i)
    
    split <- folds$splits[[i]]
    train <- rsample::analysis(split)
    test  <- rsample::assessment(split)
    
    X_train <- model.matrix(
      as.formula(paste(outcome, "~", paste(predictors, collapse = " + "))),
      train
    )[,-1]
    
    X_test <- model.matrix(
      as.formula(paste(outcome, "~", paste(predictors, collapse = " + "))),
      test
    )[,-1]
    
    y_train <- train[[outcome]]
    y_test  <- test[[outcome]]
    
    #  USAR cv.glmnet
    cv_fit <- glmnet::cv.glmnet(
      X_train, y_train,
      family = "binomial",
      alpha = alpha,
      nfolds = 5
    )
    
    prob_base <- predict(
      cv_fit,
      X_test,
      s = "lambda.min",
      type = "response"
    )
    
    auc_base <- pROC::roc(
      y_test,
      as.vector(prob_base),
      quiet = TRUE
    )$auc
    
    for (var in colnames(X_test)) {
      
      auc_perm <- replicate(n_perm, {
        Xp <- X_test
        Xp[, var] <- sample(Xp[, var])
        prob <- predict(
          cv_fit,
          Xp,
          s = "lambda.min",
          type = "response"
        )
        pROC::roc(y_test, as.vector(prob), quiet = TRUE)$auc
      })
      
      all_imp[[length(all_imp) + 1]] <- tibble::tibble(
        var = var,
        delta_auc = auc_base - mean(auc_perm)
      )
    }
  }
  
  dplyr::bind_rows(all_imp) %>%
    dplyr::group_by(var) %>%
    dplyr::summarise(
      mean_delta_auc = mean(delta_auc),
      .groups = "drop"
    ) %>%
    dplyr::arrange(desc(mean_delta_auc))
}

```

```{r}
#Se ve que la importancia por permutaci贸n (o sea importancia de cada variable en la capacidad predictiva del modelo) es diferente que la importancia de las variables segun Lasso
set.seed(123)

perm_imp_ridge <- perm_importance_cv(
  data       = data2_clean,
  outcome    = "clinical_diagnosis",
  predictors = vars,
  alpha      = 0,      #  Ridge
  v          = 10,     # CV externo
  n_perm     = 20,     # permutaciones por variable por fold
  seed       = 123
)

perm_imp_ridge

```


```{r}
library(dplyr)

# Permutation importance (Ridge)
perm_tbl <- perm_imp_ridge %>%
  rename(
    var = var,
    delta_auc = mean_delta_auc
  )

# LASSO stability (la tuya)
lasso_tbl <- lasso_importance %>%
  rename(
    var = var,
    lasso_freq = freq
  )

# Unir todo
importance_tbl <- perm_tbl %>%
  left_join(lasso_tbl, by = "var") %>%
  mutate(
    lasso_freq = ifelse(is.na(lasso_freq), 0, lasso_freq)
  )
importance_tbl
```
```{r}
#Si bien lasso y la importancia por permutaciones coinciden en varias variables, en otras no tanto. Veamos el grafico

library(ggplot2)
library(ggrepel)

ggplot(
  importance_tbl,
  aes(x = lasso_freq, y = delta_auc, label = var)
) +
  geom_point(size = 3, alpha = 0.8) +
  geom_text_repel(
    size = 4,
    max.overlaps = Inf,
    box.padding = 0.5,
    point.padding = 0.3,
    min.segment.length = 0
  ) +
  geom_vline(xintercept = 0.5, linetype = 3, color = "grey50") +
  geom_hline(yintercept = median(importance_tbl$delta_auc, na.rm = TRUE),
             linetype = 3, color = "grey50") +
  scale_x_continuous(
    limits = c(0, 1.05),
    breaks = c(0, 0.25, 0.5, 0.75, 1)
  ) +
  labs(
    x = "Estabilidad LASSO (frecuencia de selecci贸n)",
    y = "Importancia predictiva (AUC permutado)",
    title = "Importancia de variables: selecci贸n vs contribuci贸n predictiva",
    subtitle = "Comparaci贸n entre estabilidad bajo LASSO y p茅rdida de AUC al permutar"
  ) +
  theme_minimal(base_size = 14)

```

```{r}
#Entonces tengo: Variables imprescindibles, arriba a la derecha; variables prescindibles en todos los sentidos, abajo a la izquierda
#Pruebo sacar las variables prescindibles por AUC y vuelvo a calcular AUC: MEJORA un poco! a 0.696

vars2 <- c("mmse_total", "cog_category_animals", "cog_tmt_b", "cog_ed")
auc_enet_ridge <- cv_auc_elastic(
  data       = data2_clean,
  outcome    = "clinical_diagnosis",
  predictors = vars2,
  alpha      = 0,
  v          = 10
)

auc_enet_ridge

```
## Desde ac谩 en adelante creo que no dejar铆a nada

```{r}

# N煤mero de permutaciones num茅ricas
n_perm <- 1000
set.seed(123)

# Todas las combinaciones de pares
pairs <- combn(vars_to_keep, 2, simplify = FALSE)

# Dataframe para guardar resultados
cor_results <- data.frame(
  var_1 = character(),
  var_2 = character(),
  cor_original = numeric(),
  cor_perm_mean = numeric(),
  cor_perm_sd = numeric(),
  stringsAsFactors = FALSE
)

for (pair in pairs) {
  
  v1 <- pair[1]
  v2 <- pair[2]
  
  # Correlaci贸n original
  cor_orig <- cor(
    dataAD[[v1]],
    dataAD[[v2]],
    use = "complete.obs"
  )
  
  # Correlaciones permutadas
  cor_perm <- numeric(n_perm)
  
  for (i in seq_len(n_perm)) {
    df_perm <- dataAD
    df_perm[[v1]] <- sample(df_perm[[v1]])
    
    cor_perm[i] <- cor(
      df_perm[[v1]],
      df_perm[[v2]],
      use = "complete.obs"
    )
  }
  
  # Guardar resultados
  cor_results <- rbind(
    cor_results,
    data.frame(
      var_1 = label_map[v1],
      var_2 = label_map[v2],
      cor_original = cor_orig,
      cor_perm_mean = mean(cor_perm),
      cor_perm_sd = sd(cor_perm)
    )
  )
}

cor_results


```

```{r}

set.seed(123)

# columnas a analizar
v1 <- "cog_tmt_a"
v2 <- "cog_tmt_b"

# correlaci贸n original
cor_original <- cor(
  dataAD[[v1]],
  dataAD[[v2]],
  use = "complete.obs"
)

# n煤mero de permutaciones a mostrar
n_perm_show <- 5

# correlaciones permutadas
cor_perm <- numeric(n_perm_show)

for (i in seq_len(n_perm_show)) {
  df_perm <- dataAD
  df_perm[[v1]] <- sample(df_perm[[v1]])
  
  cor_perm[i] <- cor(
    df_perm[[v1]],
    df_perm[[v2]],
    use = "complete.obs"
  )
}

# armar dataframe para graficar
cor_df <- data.frame(
  tipo = c("Original", paste0("Perm ", 1:n_perm_show)),
  correlacion = c(cor_original, cor_perm)
)

cor_df

barplot(
  cor_df$correlacion,
  names.arg = cor_df$tipo,
  ylim = c(-1, 1),
  ylab = "Correlaci贸n de Pearson",
  main = paste(
    label_map[v1], "vs", label_map[v2]
  )
)

abline(h = 0, lty = 2)
```

## MODELOS LOGISTICOS

### Con todas las variables

```{r}
modelo_todas <- glm(clinical_diagnosis~., data2, family=binomial)
summary(modelo_todas)

#EL VIF ES TAN ALTO QUE NO PUEDE CALCULARLO; solo dan signif cog_ed, animals, MMSE, tmt_a_err y tmt_b_err
```
```{r}
#Veo qu茅 variables tienen coeficientes de correlaci贸n MUY altos

high_cor_pairs <- which(abs(mat_cor) > 0.70 & abs(mat_cor) < 1, arr.ind = TRUE)

for(i in seq_len(nrow(high_cor_pairs))) {
  r <- high_cor_pairs[i, ]
  cat(
    rownames(mat_cor)[r[1]],
    "<-->",
    colnames(mat_cor)[r[2]],
    ": r =",
    round(mat_cor[r[1], r[2]], 3),
    "\n"
  )
}

negative_cor_pairs <- which(abs(mat_cor) < -0.70 & abs(mat_cor) > -1, arr.ind = TRUE)
for(i in seq_len(nrow(negative_cor_pairs))) {
  r <- negative_cor_pairs[i, ]
  cat(
    rownames(mat_cor)[r[1]],
    "<-->",
    colnames(mat_cor)[r[2]],
    ": r =",
    round(mat_cor[r[1], r[2]], 3),
    "\n"
  )
}

```

### Sacamos algunas muy correlacionadas

```{r}
modelo2 <- glm(clinical_diagnosis~cog_ed+mmse_total+cog_digits_forward_total + cog_digits_backward_total+cog_digits_forward_span+cog_digits_backward_span+ cog_category_animals+ cog_tmt_a + cog_tmt_a_err +cog_tmt_a_corr+ cog_tmt_b+cog_tmt_b_err +cog_tmt_b_corr+ tests_no_hechos, data2, family=binomial)
summary(modelo2)
vif(modelo2)
```

**VIFS altisimos de las variables con digitos. Pero primero calculemos un AUC de estos modelos**

```{r}
library(pROC)

roc_todas <- roc(
  response  = modelo_todas$y,          # la y que realmente us贸 glm()
  predictor = fitted(modelo_todas)     # las probabilidades predichas
)

auc(roc_todas)

plot(
  roc_todas,
  col = "#1B9E77",
  lwd = 3,
  main = "Curva ROC - Modelo AD vs FTD (todas las variables)",
  legacy.axes = TRUE
)

auc_value <- auc(roc_todas)
text(0.6, 0.2, labels = paste("AUC =", round(auc_value, 3)), cex = 1.2)




```

## Permutaciones

### En cada variable para analizar importancia para el modelo (en delta AUC)

```{r}
perm_importance <- function(data, model_formula) {
  # modelo base
  modelo_base <- glm(model_formula, data = data2, family = binomial)
  
  # AUC base usando exactamente las filas que us贸 glm
  auc_base <- roc(modelo_base$y, fitted(modelo_base))$auc
  
  # variables predictoras (sacamos la respuesta)
  vars <- all.vars(model_formula)[-1]
  results <- data.frame(variable = vars, delta_auc = NA_real_)
  
  for (v in vars) {
    data_perm <- data2
    data_perm[[v]] <- sample(data_perm[[v]])   # permutar variable v
    
    modelo_p <- glm(model_formula, data = data_perm, family = binomial)
    
    # AUC con variable permutada
    auc_p <- roc(modelo_p$y, fitted(modelo_p))$auc
    
    results$delta_auc[results$variable == v] <- auc_base - auc_p
  }
  
  list(
    auc_base = auc_base,
    importance = results
  )
}

```

```{r}
library(dplyr)
library(pROC)

## 1) Asegurar binario AD vs FTD
data2 <- data2 %>%
  filter(clinical_diagnosis %in% c("AD", "FTD")) %>%
  mutate(dx_bin = ifelse(clinical_diagnosis == "AD", 1, 0))

## 2) Elegir variables
vars <- c(
  "cog_digits_backward_total",
  "cog_digits_forward_total",
  "cog_digits_backward_span",
  "cog_digits_forward_span",
  "cog_category_animals",
  "cog_category_vegetables",
  "cog_tmt_a",
  "cog_tmt_a_err",
  "cog_tmt_b",
  "cog_tmt_b_err",
  "cog_ed",
  "mmse_total"
)

## 3) Armar f贸rmula con esas vars
formula_base <- as.formula(
  paste("dx_bin ~", paste(vars, collapse = " + "))
)

## 4) Correr permutaciones
set.seed(1)
perm_res <- perm_importance(data2, formula_base)


perm_res$importance %>%
  arrange(desc(delta_auc))

```

